# =========================
# Dev: H2 + Hibernate ORM
# =========================
quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:mem:rickmorty;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
quarkus.datasource.username=sa
quarkus.datasource.password=sa

# Em DEV, gerar schema automaticamente (evita precisar de Flyway/Liquibase no POM)
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.hibernate-orm.log.sql=true

# =========================
# Rest Client: Rick & Morty API
# =========================
quarkus.rest-client."rickandmorty-api".url=https://rickandmortyapi.com/api
quarkus.rest-client."rickandmorty-api".connect-timeout=3000
quarkus.rest-client."rickandmorty-api".read-timeout=5000

# =========================
# Cache TTL (apenas dados externos)
# =========================
# Cache: lista por pagina (TTL 5 min)
quarkus.cache.caffeine."character-page".expire-after-write=5M

# Cache: personagem por id (TTL 10 min)
quarkus.cache.caffeine."character-by-id".expire-after-write=10M

# Cache: lista de favoritos (TTL 5 min)
quarkus.cache.caffeine."favorites-list".expire-after-write=5M

# Para o Rest Client funcionar com o prefixo rickandmorty-api, a interface do client deve estar anotada com algo como
# @RegisterRestClient(configKey = "rickandmorty-api").

# Para os TTLs acima surtirem efeito, os mï¿½todos cacheados devem usar
# @CacheResult(cacheName = "character-page") e
# @CacheResult(cacheName = "character-by-id").
